<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
</head>

<body>
  <canvas id="canvas" style="border:1px solid #000000;" width="500" height="500"></canvas>
  <br>
  <div id='Drawing'>
    <select id="tools">
      <option value='0'>Place</option>
      <option value='1'>Split</option>
      <option value='2'>Info</option>
    </select>

    <input type="text" id="colorField" value="0">
    <input type="checkbox" id="debug" name="CollisionType" />
    <span>Debug</span>
    <br>
  </div>
  <p id='Data'></p>
  <!--All the code, compressed into a single file with the relevant module lines commented out. --> 
  <script>
    "use strict";
    //Start Vector
    //export { Vector2 as default }
    //Position(Absolute) Vectors are type 0;
    //Displacement(Relative) Vectors are type 1;
    //Scaling Vectors are type 2;
    //Boolean Vectors are type 3;
    //I'm not going to comment this class because it's self explanatory
    class Vector2 {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
      }

      assign(x, y, type) {
        if (x != null) {this.x = x}
        if (y != null) {this.y = y}
        if (type != null) {this.type = type}
      }

      add(vector, mutate) {
        let newVect = new Vector2(this.x + vector.x, this.y + vector.y, this.type)
        if (mutate) { this.assign(newVect.x, newVect.y)} else { return newVect }
      }
      subtract(vector, mutate) {
        let newVect = new Vector2(this.x - vector.x, this.y - vector.y, this.type)
        if (mutate) { this.assign(newVect.x, newVect.y) } else { return newVect }
      }
      multiply(vector, mutate) {
        let newVect = new Vector2(this.x * vector.x, this.y * vector.y, this.type)
        if (mutate) {this.assign(newVect.x, newVect.y)} else {return newVect}
      }
      multiplyScalar(scalar, mutate) {
        let newVect = new Vector2(this.x * scalar, this.y * scalar, this.type)
        if (mutate) {this.assign(newVect.x, newVect.y)} else {return newVect}
      }
      divide(vector, mutate) {
        let newVect = new Vector2(this.x / vector.x, this.y / vector.y, this.type)
        if (mutate) {this.assign(newVect.x, newVect.y)} else {return newVect}
      }
      divideScalar(scalar, mutate) {
        let newVect = new Vector2(this.x / scalar, this.y / scalar, this.type)
        if (mutate) {this.assign(newVect.x, newVect.y)} else {return newVect}
      }
      invert(mutate) {
        if (mutate) { this.multiplyScalar(-1, true) } else { return this.multiplyScalar(-1) }
      }
      abs(mutate) {
        let newVect = new Vector2(Math.abs(this.x), Math.abs(this.y), this.type)
        if (mutate) {this.assign(newVect.x, newVect.y)} else {return newVect}
      }

      length() { return Math.sqrt(this.x ** 2 + this.y ** 2) }
      slope() { return this.y / this.x }
      clone() { return new Vector2(this.x, this.y, this.type) }
      sign() {
        let xSign, ySign;
        if (this.x != 0) { xSign = this.x / Math.abs(this.x) } else { xSign = 0 }
        if (this.y != 0) { ySign = this.y / Math.abs(this.y) } else { ySign = 0 }
        return new Vector2(xSign, ySign, 2)
      }
      rotate(angle) {
        throw "Does not exist"
      }

    }
    //End Vector
    //Start Render
    const canvas = document.getElementById("canvas");
    const can = canvas.getContext("2d");
    // export { drawPoint, drawBox, outlineBox, drawLine }
    //I'm not going to comment this class because it's self explanatory
    const Render = {

      drawPoint(pos, color) {
        can.fillStyle = color;
        can.fillRect(pos.x - 2, pos.y - 2, 4, 4)
      },

      drawBox(pos, length, color) {
        can.fillStyle = color;
        can.fillRect(pos.x, pos.y, length.x, length.y);
      },

      outlineBox(pos, length, color) {
        can.strokeStyle = color;
        can.strokeRect(pos.x, pos.y, length.x, length.y);
      },

      drawLine(start, end, color) {
        if (end.type == 1) {end = end.add(start)}
        can.strokeStyle = color;
        can.beginPath();
        can.moveTo(start.x, start.y);
        can.lineTo(end.x, end.y);
        can.stroke();
      }
    }
    //End Render
    //Start Physics
    //import Vector2 from "./Vector2.js";
    //export { PhysObject as default }
    class PhysObject {
      constructor(x, y, drag) {
        this.position = new Vector2(x, y, 0);
        this.rotation = 0;
        this.velocity = new Vector2(0, 0, 1)
        this.acceleration = new Vector2(0, 0, 1)
        this.decay = drag;
      }

      applyForce(acceleration) {
        this.acceleration.add(acceleration, true);
      }

      updateVelocity() {
        this.velocity.add(this.acceleration, true);
        //Easy drag until I think of a better solution
        this.velocity.multiplyScalar(this.decay, true);
        //Bring axis to rest after it's moving by less than .001 (units?)
        if (Math.abs(this.velocity.x) < .001) { this.velocity.x = 0 }
        if (Math.abs(this.velocity.y) < .001) { this.velocity.y = 0 }
        //Acceleration has been applied, now it's set back to 0
        this.acceleration.assign(0, 0);
      }

      applyPartialVelocity(velocity) {
        //Assumes this is being used to step through collisions and as such
        //Expects velocity to end up at 0 (Probably a bad way to do it)
        //Need to look into this at some point
        this.position.add(velocity, true);
        this.velocity.subtract(velocity, true);
      }

      applyMovement(velocity) {
        this.position.add(velocity, true);
      }

      updatePosition() {
        this.position.add(this.velocity, true);
      }

    }
    //End Physics
    //Start Quadtree
    ///export { Quadtree as default }
    //Used for easily reading data retrieved by readNode()
    class Node {
      constructor(type, data) {
        this.type = type;
        this.data = data;
      }
    }
    class Quadtree {
      constructor(depth, nullVal) {
        this.depth = depth;
        this.tree = []
        for (let i = 0; i < depth; i++) { this.tree[i] = [] }
        this.Assign(1, 0, nullVal)
        this.nullVal = nullVal;
      }

      //Key Manipulation
      getLayer(externalKey) {
        //Decodes layer from an externalKey
        let strKey = externalKey.toString(2)
        if (strKey.length % 2 == 1) { return (strKey.length - 1) / 2 }
        else { throw new RangeError('getLayer ' + externalKey) }
      }

      internalKey(externalKey, layer) {
        //Decodes internalKey from an externalKey
        //Layer is inputted instead of getLayer()ed because
        //the relevant scope always already has layer defined
        return externalKey - 2 ** (2 * layer)
      }

      encodeKey(x, y, layer) {
        //Encodes an x value, y value, and layer into an externalKey
        //X and Y are encoded via Z-Order Curve (xyxyxy...)
        //Layer is encoded by using a 1 to preserve leading 0 bits
        if (x < 0 || x > 2 ** layer - 1 || y < 0 || y > 2 ** layer - 1) { throw new RangeError('Encode') }
        let xStr = x.toString(2), yStr = y.toString(2), output = '1';
        while (xStr.length < layer) { xStr = '0' + xStr }
        while (yStr.length < layer) { yStr = '0' + yStr }
        for (let i = 0; i < layer; i++) { output += xStr[i] + yStr[i] }
        return parseInt(output, 2)
      }

      decodeKey(key) {
        //Decodes an externalKey into it's x, y, and layer components
        let layer = this.getLayer(key), x = 0, y = 0;
        for (let i = 0; i < layer; i++) {
          y += (key % 2) * (2 ** i); key >>= 1;
          x += (key % 2) * (2 ** i); key >>= 1;
        }
        return [x, y, layer]
      }

      getKeyProgession(key) {
        //Returns the externalKey of each layer
        //List starts at 1 (Layer 0) and descends until it reaches key (Layer n)
        let layer = this.getLayer(key);
        if (layer > this.depth) { throw new RangeError('Key unreachable; gKP') }
        let progression = [key];
        for (let i = 1; i <= layer; i++) { progression.push(key >>= 2) }
        return progression.reverse()
      }

      sortKeys(keys) {
        //Sorts a list of keys based on their relative position
        //on the ZOC of the deepest key provided
        let maxLayer = this.getLayer(Math.max(...keys));
        let balancedMap = new Map(), balancedKeys = [], result = [];
        keys.forEach((key) => {
          let layer = this.getLayer(key), bigKey = key << 2 * (maxLayer - layer);
          balancedMap.set(bigKey, key); balancedKeys.push(bigKey);
        })
        balancedKeys.sort((a, b) => a - b)
        balancedKeys.forEach((key) => { result.push(balancedMap.get(key)) });
        return result
      }

      //Tree Reading
      readNode(key) {
        let layer = this.getLayer(key)
        let node = this.tree[layer][this.internalKey(key, layer)]
        if (node == undefined) { return undefined }
        let data = node >> 1; let type = node % 2;
        return new Node(type, data)
      }

      getSide(key, xOff, yOff) {
        //Gets all keys sharing a face with key on the offset x[1 or -1] and y[1 or -1]
        let coords = this.decodeKey(key); let keyList = []; let foundKeys = [];
        //If requested area lies beyond quadtree's boundaries, terminate
        try { keyList.push(this.encodeKey(coords[0] + xOff, coords[1] + yOff, coords[2])) } catch (error) { return }
        //Determines the modifiers adjacent keys require
        let kidMods = new Set([0, 1, 2, 3]);
        if (xOff < 0) { kidMods.delete(0); kidMods.delete(1); }
        else if (xOff > 0) { kidMods.delete(2); kidMods.delete(3); }
        if (yOff < 0) { kidMods.delete(0); kidMods.delete(2); }
        else if (yOff > 0) { kidMods.delete(1); kidMods.delete(3); }
        //While some relevant nodes haven't been searched
        while (keyList.length != 0) {
          let currentKey = keyList.pop()
          let node = this.readNode(currentKey);
          if (node == undefined) { keyList.push(currentKey >>= 2) }
          else if (node.type == 0) { foundKeys.push(currentKey) }
          else if (node.type == 1) {
            //Add new keys to be searched
            let newKey = currentKey << 2;
            kidMods.forEach((mod) => { keyList.push(newKey + mod) })
          }
        }
        return this.sortKeys(foundKeys)
      }

      getKids(key, first) {
        //Recursively catalogues all children nodes of key
        //Maybe flip so kids[0] is type 1 && kids[1] is type 0?
        if (first == undefined) { this.kids = [[], []] }
        let node = this.readNode(key);
        if (node.type == 0) { this.kids[0].push(key) }
        else if (node.type == 1) {
          this.kids[1].push(key);
          let newKey = key << 2;
          for (let i = 0; i < 4; i++) { this.getKids(newKey + i, false) }
        }
        //Ensure we only return on the first call
        if (first == undefined) {
          let kidList = this.kids;
          delete this.kids;
          return kidList
        }
      }

      encodeSaveData(key, data) {
        //Converts key to maximum depth (Not actually required anymore?)
        //Adds largeKey hexadecimal string to data hexadecimal string
        let keyLayer = this.getLayer(key), largeStr = '1';
        if (keyLayer < this.depth) {
          for (let i = keyLayer; i < this.depth; i++) { largeStr += '00' }
        }
        let largeKey = parseInt(largeStr + key.toString(2), 2);
        return largeKey.toString(16) + data.toString(16) + ' ';
      }

      nonNullValSave() {
        //Saves each node who's value isn't equal to this.nullVal
        let result = '', nodes = this.getKids(1);
        nodes[0].forEach((key) => {
          let node = this.readNode(key);
          if (node.data != this.nullVal) { result += this.encodeSaveData(key, node.data); }
        })
        return result
      }

      LODSave() {
        //Saves each node who's value/LODVal differs from the value/LODVal of it's parent
        let result = '', allNodes = this.getKids(1), nodes = [...allNodes[1], ...allNodes[0]];
        let start = nodes.shift(); result += this.encodeSaveData(start, this.readNode(start).data);
        nodes.forEach((key) => {
          let node = this.readNode(key);
          if (node.data != this.readNode(key >> 2).data) { result += this.encodeSaveData(key, node.data); }
        })
        return result
      }

      bestSave() {
        //Compares the length of both saves
        //Returns shorter data string
        let nNVS = this.nonNullValSave();
        let LODS = this.LODSave();
        if (LODS.length <= nNVS.length) { return LODS }
        else { return nNVS }
      }

      //Tree Manipulation
      encodeData(type, data) {
        //Internally stores data&type together
        return (data << 1) + type;
      }

      setNode(externalKey, value) {
        //Sets tree[layer][internalKey] to value
        let layer = this.getLayer(externalKey);
        this.tree[layer][this.internalKey(externalKey, layer)] = value;
      }

      Assign(key, type, data, genLOD) {
        //Calls setNode with proper data encoding
        //Requests LOD regeneration
        this.setNode(key, this.encodeData(type, data));
        if (genLOD != false && key != 1) { this.generateLOD(key >> 2) }
      }

      Replace(key, value, merge) {
        //Calls Assign, deletes all children of key
        //Attempts to merge key
        let node = this.readNode(key);
        if (node.type == 1) {
          let kids = this.getKids(key).flat();
          kids.forEach((kid) => { this.setNode(kid, undefined) })
        }
        this.Assign(key, 0, value, true);
        if (key != 1 && merge) { this.Merge(key >> 2, false) }
      }

      Populate(key, data) {
        //Creates a path in the tree,
        //placing any required parent nodes down to key
        let steps = this.getKeyProgession(key);
        for (let i = 0; i < steps.length - 1; i++) {
          let node = this.readNode(steps[i]);
          if (node.type == 0) { this.Split(steps[i]) }
        }
        this.Replace(key, data, false);
      }

      Split(key) {
        //Turns node at Key into a parent of four identical children nodes
        let node = this.readNode(key);
        if (node.type == 0) {
          if (this.getLayer(key) < this.depth - 1) {
            let newKey = key << 2;
            for (let i = 0; i < 4; i++) { this.Assign(newKey + i, 0, node.data, false) }
            this.Assign(key, 1, node.data, false);
          }
          else { console.log('Cannot Split Lowest Level: ' + key) }
        }
        else { console.log('Cannot Split Branch:' + key) }
      }

      Merge(key, first) {
        //Attempts to merge four children nodes into key
        //Recursively attempts merges so long as one of the four kids
        //Is a type 1 (parent) node
        let node = this.readNode(key);
        if (node.type == 0) { console.log('Cannot merge leaf: ' + key) }
        else if (first == undefined) {
          //Get a list of all children of key if first call, sorted from deepest to shallowest
          let branches = this.getKids(key)[1].sort((a, b) => b - a);
          branches.forEach((branch) => { this.Merge(branch, false) })
        }
        else if (node.type == 1) {
          let kidVals = new Set(), newKey = key << 2, value;
          for (let i = 0; i < 4; i++) {
            let newNode = this.readNode(newKey + i);
            if (newNode.type == 0) {
              value = newNode.data;
              kidVals.add(value);
            }
            else if (newNode.type == 1) { kidVals.add(undefined) }
          }
          if (kidVals.size == 1 && value != undefined) { this.Replace(key, value) }
        }
      }

      Load(data) {
        //Loads data generated by a save function into tree
        //May need simplification
        let hexaLength = Math.ceil((2 + 2 * this.depth) / 4), divs = data.split(' ');
        if (divs[0].length - 1 > hexaLength) { throw 'Load exceeds depth limit' }
        divs.forEach((info) => {
          if (info.length >= 1) {
            let strKey = info.substring(0, info.length - 1);
            let key = parseInt(parseInt(strKey, 16).toString(2).substring(1), 2)
            let data = parseInt(info[info.length - 1], 16);
            this.Populate(key, data);
          }
        })
      }

      generateLOD(key) {
        //Determines the most common value among the four children of key
        //Sets node at key to that value (while remaining type 1)
        if (key < 1) { console.log('Invalid key' + key); return }
        let node = this.readNode(key);
        if (node == undefined) { throw 'Invalid Key ' + key }
        if (node.type == 0) { console.log('Cannot generateLOD of a leaf: ' + key) }
        else if (node.type == 1) {
          let newKey = key << 2, kidVals = new Set(), lodVal;
          for (let i = 0; i < 4; i++) {
            let kidNode = this.readNode(newKey + i);
            lodVal = kidNode.data;
            if (kidVals.has(kidNode.data)) { break }
            else { kidVals.add(kidNode.data) }
          }
          if (node.data != lodVal && key != 1) { this.Assign(key, node.type, lodVal, true) }
        }
      }

    }
    //End Quadtree
    //Start Region
    //import Quadtree from "./Quadtree.js";
    //import Vector2 from "./Vector2.js"
    //import PhysObject from "./Physics.js";
    //import * as Render from "./Render.js";
    //export { Region, blockMap }
    //Data Classes
    class box {
      constructor(x, y, width, height) {
        this.position = new Vector2(x, y, 0)
        this.length = new Vector2(width, height, 1)
        this.center = this.position.add(this.length.divideScalar(2))
      }
    }
    class corner {
      constructor(point, key, direction) {
        this.point = point;
        this.key = key;
        this.direction = direction;
      }
    }
    class hitData {
      constructor(point, wall, key, keys) {
        this.point = point;
        this.wall = wall; // Rename to direction?
        this.key = key;
        this.keys = keys;
        this.distance;
      }
    }
    //Real Deal
    class Region extends Quadtree {
      constructor(x, y, width, height, blockMap) {
        super(5, 0);
        this.physics = new PhysObject(x, y, .9);
        this.length = new Vector2(width, height, 1);
        this.blockMap = blockMap;
        this.cornerList = [];
        this.debug = true;
      }

      getBoxDimensions(key) {
        let coords = this.decodeKey(key);
        let scale = 2 ** coords[2];
        let width = this.length.x / scale, height = this.length.y / scale;
        let x = coords[0] * width + this.physics.position.x;
        let y = coords[1] * height + this.physics.position.y;
        return new box(x, y, width, height)
      }

      Render() {
        //Draws each square
        //Maybe take out and put in dedicated rendering class?
        //Maybe use LODS to draw less squares?
        let keys = this.getKids(1);
        keys[0].forEach((leaf) => {
          let node = this.readNode(leaf);
          if (node.data != 0) {
            let box = this.getBoxDimensions(leaf);
            let color = this.blockMap.getBlock(node.data).color;
            Render.drawBox(box.position, box.length, color);
          }
        })
        //if (this.debug) {
        //Draw all grids
        Render.outlineBox(this.physics.position, this.length, 'black');
        keys[1].forEach((branch) => {
          let box = this.getBoxDimensions(branch);
          Render.drawLine(new Vector2(box.position.x, box.center.y, 0), new Vector2(box.length.x, 0, 1), 'black');
          Render.drawLine(new Vector2(box.center.x, box.position.y, 0), new Vector2(0, box.length.y, 1), 'black');
        })
        //}
      }

      Draw(func, key, color) {
        //Simplifies calls to certain render functions
        let boxDim = this.getBoxDimensions(key);
        func(boxDim.position, boxDim.length, color)
      }

      //Corner Start
      getCorners(key) {
        //Returns all exposed corners (both sides not covered)
        let top = this.getSide(key, 0, -1);
        let bottom = this.getSide(key, 0, 1);
        let left = this.getSide(key, -1, 0);
        let right = this.getSide(key, 1, 0);
        let result = new Set();
        //top left 0
        if ((top == undefined || this.readNode(top[0]).data == this.nullVal) &&
          (left == undefined || this.readNode(left[0]).data == this.nullVal)) {
          result.add(0);
        }
        //bottom left 1
        if ((bottom == undefined || this.readNode(bottom[0]).data == this.nullVal) &&
          (left == undefined || this.readNode(left[left.length - 1]).data == this.nullVal)) {
          result.add(1);
        }
        //top right 2
        if ((top == undefined || this.readNode(top[top.length - 1]).data == this.nullVal) &&
          (right == undefined || this.readNode(right[0]).data == this.nullVal)) {
          result.add(2);
        }
        //bottom right 3
        if ((bottom == undefined || this.readNode(bottom[bottom.length - 1]).data == this.nullVal) &&
          (right == undefined || this.readNode(right[right.length - 1]).data == this.nullVal)) {
          result.add(3);
        }
        return result
      }

      findCorners() {
        //Finds the corners of all leaves and stores them in cornerList
        let kids = this.getKids(1)[0];
        this.cornerList = [];
        kids.forEach((key) => {
          let node = this.readNode(key);
          if (node.data != this.nullVal) {
            let box = this.getBoxDimensions(key), corners = this.getCorners(key);
            box.position.subtract(this.physics.position, true);
            if (corners.has(0)) { this.cornerList.push(new corner(box.position, key, 0)) }
            if (corners.has(1)) { this.cornerList.push(new corner(new Vector2(box.position.x, box.position.y + box.length.y, 0), key, 1)) }
            if (corners.has(2)) { this.cornerList.push(new corner(new Vector2(box.position.x + box.length.x, box.position.y, 0), key, 2)) }
            if (corners.has(3)) { this.cornerList.push(new corner(box.position.add(box.length), key, 3)) }
          }
        })
      }

      drawCorners() {
        if (this.debug) { this.cornerList.forEach((corner) => { Render.drawPoint(corner.point.add(this.physics.position), 'yellow') }) }
      }
      //Corner End
      //Collision/Physics Start
      readColType(key) {
        //Reads the blockmap for the data stored in node of key
        //Returns collisiontype of that node
        return this.blockMap.getBlock(this.readNode(key).data).collisionType
      }

      getKeys(point) {
        //Takes an x, y coordiate-pair
        //Returns four possible keys that pair might fall into
        let originPoint = point.subtract(this.physics.position);
        let keys = []; let badcount = 0; let offset = .001;
        for (let i = 0; i < 2; i++) {
          for (let j = 0; j < 2; j++) {
            for (let layer = 0; layer < this.depth; layer++) {
              let scaledX = Math.floor(originPoint.x / ((this.length.x + offset - i * offset) / 2 ** layer));
              let scaledY = Math.floor(originPoint.y / ((this.length.y + offset - j * offset) / 2 ** layer));
              if (originPoint.x == 0 && i == 0) { scaledX = -1 }
              if (originPoint.y == 0 && j == 0) { scaledY = -1 }
              try {
                let key = this.encodeKey(scaledX, scaledY, layer);
                let node = this.readNode(key);
                if (node.type == 0) { keys.push(key); break }
              } catch (error) { keys.push(undefined); badcount += 1; break }
            }
          }
        }
        if (badcount == 4) { return undefined }
        return keys
      }

      pointCull(velocity) {
        //Culls obviously useless points using velocity
        //Used to simplify collision checks
        let cullSet = new Set([0, 1, 2, 3]);
        if (velocity.x == 0 && velocity.y != 0) {
          if (velocity.y < 0) { cullSet.delete(1); cullSet.delete(3) }
          else if (velocity.y > 0) { cullSet.delete(0); cullSet.delete(2) }
        }
        else if (velocity.x != 0 && velocity.y == 0) {
          if (velocity.x < 0) { cullSet.delete(2); cullSet.delete(3) }
          else if (velocity.x > 0) { cullSet.delete(0); cullSet.delete(1) }
        }
        else if (velocity.x < 0 && velocity.y < 0) { cullSet.delete(3) }
        else if (velocity.x < 0 && velocity.y > 0) { cullSet.delete(2) }
        else if (velocity.x > 0 && velocity.y < 0) { cullSet.delete(1) }
        else if (velocity.x > 0 && velocity.y > 0) { cullSet.delete(0) }
        return cullSet
      }

      keyCull(keys, direction, velocity) {
        //Decides which of the four keys generated by getKeys()
        //should be used to determine collisions
        let velDirection = velocity.sign();
        if (keys == undefined) { keys = [] }
        let keyList = new Set([0, 1, 2, 3]), key;
        if (velocity.x < 0) { keyList.delete(2); keyList.delete(3); }
        else if (velocity.x > 0) { keyList.delete(0); keyList.delete(1); }
        if (velocity.y < 0) { keyList.delete(1); keyList.delete(3); }
        else if (velocity.y > 0) { keyList.delete(0); keyList.delete(2); }
        let keyOptions = [];
        keyList.forEach((index) => { keyOptions.push(keys[index]) })
        if (keyOptions.length == 2) {
          if (velDirection.x != 0) {
            //Chose between Y keys
            if (direction == 0 || direction == 2) { key = keyOptions[1] }
            if (direction == 1 || direction == 3) { key = keyOptions[0] }
          }
          else if (velDirection.y != 0) {
            //Choose between X keys
            if (direction == 0 || direction == 1) { key = keyOptions[1] }
            if (direction == 2 || direction == 3) { key = keyOptions[0] }
          }
        }
        else { key = keyOptions[0] }
        return key
      }

      stepSquare(startPoint, velocity, key) {
        //Finds the point a velocity will cause the startingPoint to collide to within a key
        let flip = 1, hit = new hitData(startPoint.clone(), velocity.sign());
        if (key == undefined) { key = 1; flip = -1; } else if (this.readColType(key) != 0) { flip = -1 }
        let box = this.getBoxDimensions(key);
        let directionPoint = box.center.add(box.length.divideScalar(2).multiply(hit.wall).multiplyScalar(flip))
        let wallDistance = directionPoint.subtract(startPoint); wallDistance.type = 1
        let slope = velocity.slope(); let slopeToCorner = Math.abs(wallDistance.slope());
        if (slopeToCorner == Math.abs(slope)) { hit.point.add(wallDistance, true) }
        else if (slopeToCorner > Math.abs(slope)) {
          hit.point.add(new Vector(wallDistance.x, slope * wallDistance.x, 0), true); hit.wall.y = 0;
        }
        else if (slopeToCorner < Math.abs(slope)) {
          hit.point.add(new Vector(1 / slope * wallDistance.y, wallDistance.y, 0), true); hit.wall.x = 0;
        }
        if (this.debug) { Render.drawPoint(hit.point, 'red'); Render.drawLine(startPoint, wallDistance, 'orange'); }
        return hit
      }

      calcHit(cornerPos, direction, velocity) {
        //Calls stepSquare each time a new square is hit until 
        //a collidable square is hit or velocity has been traveled
        let distance = velocity.length(); if (distance == 0) { return }
        let traveled = 0, point = cornerPos, hit = new hitData();
        hit.keys = this.getKeys(point);
        hit.key = this.keyCull(hit.keys, direction, velocity);
        while (distance > traveled) {
          hit = this.stepSquare(point, velocity, hit.key);
          hit.keys = this.getKeys(hit.point);
          hit.key = this.keyCull(hit.keys, direction, velocity);
          if (hit.key == undefined) { traveled = distance } //Hitting Edge of Region
          else {
            if (this.readColType(hit.key) != 0) { break } //Hitting Wall
            else {
              traveled += hit.point.subtract(point).length();
              point = hit.point;
            }
          }
        }
        return hit
      }

      //Collision Safety Checks
      slideCheck(hitData) {
        //Checks if a corner should be collided with or if it should be slid past
        let xKey, yKey; let result = new Vector(true, true, 3)
        if (hitData.wall.x == 1 && hitData.wall.y == 1) { xKey = hitData.keys[1]; yKey = hitData.keys[2]; }
        else if (hitData.wall.x == -1 && hitData.wall.y == 1) { xKey = hitData.keys[3]; yKey = hitData.keys[0]; }
        else if (hitData.wall.x == 1 && hitData.wall.y == -1) { xKey = hitData.keys[0]; yKey = hitData.keys[3]; }
        else if (hitData.wall.x == -1 && hitData.wall.y == -1) { xKey = hitData.keys[2]; yKey = hitData.keys[1]; }

        if (xKey != undefined && this.readColType(xKey) != 0) { result.x = false }
        if (yKey != undefined && this.readColType(yKey) != 0) { result.y = false }
        return result
      }

      wallHangCheck(cornerKey, cornerRegion, hitKey, hitRegion) {
        //Checks if a face should be collided with
        let truth = new Vector(false, false, 3);
        let cornerBox = cornerRegion.getBoxDimensions(cornerKey);
        let hitBox = hitRegion.getBoxDimensions(hitKey);
        let boxOffset = cornerBox.center.subtract(hitBox.center).abs();
        if (this.debug) {
          Render.outlineBox(hitBox.position, hitBox.length, 'red');
          Render.outlineBox(cornerBox.position, cornerBox.length, 'purple');
        }
        if (boxOffset.x >= boxOffset.y) { truth.assign(true) }
        if (boxOffset.x <= boxOffset.y) { truth.assign(null, true) }
        return truth
      }

      checkCollision(start, velocity, target) {
        //Compares the solutions found by each useful corner, returns the shortest
        let finalHit;
        let currentVelocity = velocity.clone();
        let cullSet = this.pointCull(velocity), culledCorners = [];
        this.cornerList.forEach((corner) => { if (cullSet.has(corner.direction)) { culledCorners.push(corner) } })
        for (let i = 0; i < culledCorners.length; i++) {
          let corner = culledCorners[i];
          let cornerPoint = corner.point.add(start);
          let hit = target.calcHit(cornerPoint, corner.direction, currentVelocity);
          //If hitting something I need to collide with
          if (hit != undefined && hit.key != undefined && target.readColType(hit.key) != 0) {
            hit.distance = hit.point.subtract(cornerPoint);
            let slide, updateX = false, updateY = false;
            let wallHangCheck = this.wallHangCheck(corner.key, this, hit.key, target);
            if (hit.wall.x != 0 && hit.wall.y != 0) { slide = target.slideCheck(hit) } else { slide = new Vector(true, true, 3) }
            if (wallHangCheck.x && slide.x) { updateX = true } else { hit.wall.x = 0 }
            if (wallHangCheck.y && slide.y) { updateY = true } else { hit.wall.y = 0 }
            //If collision is valid, check if it's shorter than current best alternative
            if ((updateX || updateY) && hit.distance.length() < currentVelocity.length()) {
              currentVelocity = hit.distance
              if (hit.distance.length() == 0) { return hit } else { finalHit = hit }
            }
          }
        }
        return finalHit
      }

      moveWithCollisions(target) {
        //Checks collisions in the xy direction, then in either the x or y direction depending on velocity
        let foundWalls = new Vector(false, false, 3);
        while ((!foundWalls.x || !foundWalls.y)) {
          let hit = this.checkCollision(this.physics.position, this.physics.velocity, target);
          if (hit == undefined || (hit.wall.x == 0 && hit.wall.y == 0)) { this.physics.updatePosition(); break } //Move normally
          else {
            this.physics.applyPartialVelocity(hit.distance);
            if (hit.wall.x != 0) { foundWalls.x = true; this.physics.velocity.x = 0 }
            if (hit.wall.y != 0) { foundWalls.y = true; this.physics.velocity.y = 0 }
          }
        }
      }

      //Collision/Physics End
    }
    //Extra Stuff
    class Block {
      constructor(color, collisionType) {
        this.color = color;
        this.collisionType = collisionType;
      }
    }
    class blockMap {
      constructor(nullVal) {
        this.blockList = new Map();
        this.addBlock(0, nullVal, 0);
      }

      getBlock(id) { return this.blockList.get(id) }

      addBlock(id, color, collisionType) { this.blockList.set(id, new Block(color, collisionType)) }

      import() {

      }

      export() {

      }
    }
    //End Region
    //Start Game
    //import { Region, blockMap } from './modules/Region.js';
    //import * as Render from './modules/Render.js';
    //import Vector2 from "./modules/Vector2.js";
    //const canvas = document.getElementById("canvas");
    let canData = canvas.getBoundingClientRect();

    const a = new Region(80, 80, 320, 320, new blockMap('#ffffff'));
    a.blockMap.addBlock(1, '#777777', 1);
    a.Load('8401 8411 9081 8441 8451 8481 84a1 93d1 93e1 93f1 8501 8511 8541 95d1 95e1 95f1 85d1 9791 85f1 8601 8621 9911 9921 9931 9941 8661 8671 86e1 86f1 9c51 8721 8731 9d11 8751 9d81 9da1 8771 87a1 87b1 9f21 9f31 9f61 87e1 87f1');
    a.findCorners();

    const p = new Region(145, 185, 20, 20, new blockMap('#ffffff'));
    p.blockMap.addBlock(1, '#dd7777', 1);
    p.Load('8011');
    p.findCorners();

    //Order rendering should be done in
    let list = [a, p];

    let currentMove = p;
    let currentEdit = a;
    let curMode = 0;

    function assignDebug(boolean) {
      list.forEach((object) => { object.debug = boolean })
    }

    document.getElementById('tools').addEventListener("change", (event) => {
      curMode = Number(event.target.selectedOptions[0].getAttribute("value"))
    })

    onmousedown = (mouse) => {
      if (mouse.pageY > canData.top &&
        mouse.pageY < canData.bottom &&
        mouse.pageX > canData.left &&
        mouse.pageX < canData.right) {
        let mousePos = new Vector2(mouse.offsetX, mouse.offsetY);
        mousePos.subtract(currentEdit.physics.position, true);
        if (mousePos.x > 0 && mousePos.y > 0 &&
          mousePos.x < currentEdit.length.x &&
          mousePos.y < currentEdit.length.y) {
          let key = Math.max(...currentEdit.getKeys(mousePos.add(currentEdit.physics.position)));
          let color = Number(document.getElementById('colorField').value);
          switch (curMode) {
            case 0:
              currentEdit.Replace(key, color, true);
              break
            case 1:
              currentEdit.Split(key);
              break
            case 2:
              let node = currentEdit.readNode(key);
              let info = key + ' ' + node.data + ' ' + currentEdit.blockMap.getBlock(node.data).color;
              document.getElementById('Data').innerHTML = info;
              break
          }
          currentEdit.Render();
          currentEdit.findCorners();
        }
      }
    }
    let keyMove = new Set();
    let keyRemove = new Set();
    onkeydown = (event) => { keyMove.add(event.key) }
    onkeyup = (event) => { keyRemove.add(event.key) }

    let speed = .25;
    let gravity = new Vector2(0, .3, 1);
    const game = setInterval(() => {
      let debugCheck = document.getElementById("debug").checked;
      if (debugCheck == 0) { assignDebug(false) } else { assignDebug(true) }
      Render.drawBox(new Vector2(0, 0, 0), new Vector2(canData.right, canData.bottom, 1), 'white');
      //if (keyMove.has('w') && keyMove.has('s')) { }
      if (keyMove.has('w')) { currentMove.physics.applyForce(new Vector2(0, 2 * -speed)) }
      //else if (keyMove.has('s')) { currentMove.physics.applyForce(new Vector2(0, window.speed)) }
      if (keyMove.has('a') && keyMove.has('d')) { }
      else if (keyMove.has('a')) { currentMove.physics.applyForce(new Vector2(-speed, 0)) }
      else if (keyMove.has('d')) { currentMove.physics.applyForce(new Vector2(speed, 0)) }
      currentMove.physics.applyForce(gravity);
      keyRemove.forEach((key) => { keyMove.delete(key) })
      keyRemove.clear();
      list.forEach((object) => {
        object.Render();
        object.drawCorners();
      })
      p.physics.updateVelocity();
      p.moveWithCollisions(a);
    }, 1000 / 60);
    //End Game
  </script>
  
</body>

</html>